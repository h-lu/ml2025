import streamlit as st

st.set_page_config(
    page_title="思考与练习",
    page_icon="✏️",
    layout="wide"
)

st.title("思考与练习")

st.markdown("""
以下是本周的思考问题和练习题，这些问题旨在帮助您巩固对K-Means和层次聚类的理解。
尝试先自己思考回答，然后点击"查看参考答案"来检验您的理解。
""")

# 创建问题列表
questions = [
    {
        "question": "1. K-Means的主要局限性有哪些？在什么情况下它可能不是最佳选择？",
        "answer": """
        K-Means的主要局限性包括：
        
        * **需要预先指定K值**：K值的选择对结果影响很大，选择不当会导致次优的聚类效果
        * **对初始质心敏感**：不同的初始质心可能导致不同的聚类结果，可能陷入局部最优
        * **对非球状簇效果不佳**：K-Means假设簇是凸形的、各向同性的（类似圆形或球形），难以发现非规则形状的簇
        * **对异常值敏感**：异常值会对质心的计算产生较大影响，可能导致簇的划分发生偏移
        
        在以下情况下，K-Means可能不是最佳选择：
        
        * 当数据簇呈现非球状、非凸或复杂形状时
        * 当簇的大小差异很大时
        * 当数据中存在大量异常值时
        * 当无法事先确定合适的K值时
        * 当需要理解数据的层次结构时
        """
    },
    {
        "question": "2. 解释凝聚式层次聚类和分裂式层次聚类的区别。为什么凝聚式更常用？",
        "answer": """
        **凝聚式层次聚类（Agglomerative）**：
        * 自底向上的方法
        * 开始时每个数据点自成一簇
        * 逐步合并最相似的簇
        * 直到所有点合并为一个簇
        
        **分裂式层次聚类（Divisive）**：
        * 自顶向下的方法
        * 开始时所有数据点在一个簇
        * 逐步分裂最不相似的簇
        * 直到每个点自成一簇
        
        **凝聚式层次聚类更常用的原因**：
        
        1. **计算效率更高**：分裂式方法需要考虑所有可能的分裂方式，计算复杂度为O(2^n)，而凝聚式方法的复杂度为O(n^3)或O(n^2log n)
        2. **实现更简单**：凝聚式算法更容易实现，逻辑更清晰
        3. **可用性更广**：在大多数统计软件和机器学习库中都有标准实现
        4. **适用于大多数实际应用场景**：在许多实际应用中，凝聚式方法的结果已经足够好
        """
    },
    {
        "question": "3. 什么是连接标准 (Linkage Criteria)？'Ward'连接和'Single'连接的主要区别和适用场景是什么？",
        "answer": """
        **连接标准(Linkage Criteria)**是层次聚类中用来定义如何计算簇之间距离的规则，决定了哪两个簇应该被合并。
        
        **Ward连接**：
        * 定义：最小化簇内方差的增量
        * 计算方式：计算合并两个簇后簇内平方和增加的量，选择增量最小的两个簇合并
        * 特点：倾向于产生大小相似的紧凑球状簇
        * 适用场景：当簇预期是凸形、大小相似时；对大多数常规数据集效果较好
        * 限制：只能与欧氏距离一起使用
        
        **Single连接**：
        * 定义：计算两个簇中所有点对之间距离的最小值
        * 计算方式：找到簇A和簇B中距离最近的两个点的距离
        * 特点：能够识别非凸形状的簇，但容易受噪声影响，产生"链式效应"
        * 适用场景：当簇可能是任意形状，特别是非凸形状时；对寻找"连通组件"有效
        * 限制：对噪声和异常值敏感，可能导致不平衡的簇
        
        **主要区别**：
        * Ward关注簇内方差，Single关注点对最近距离
        * Ward倾向于产生紧凑球状簇，Single可以识别任意形状的簇
        * Ward对噪声较为稳健，Single对噪声敏感
        * Ward通常产生更平衡的簇大小，Single可能产生链状效应和不平衡簇
        """
    },
    {
        "question": "4. 如何解读树状图 (Dendrogram)？如何利用它来帮助选择簇的数量？",
        "answer": """
        **树状图(Dendrogram)解读**：
        
        * **垂直线**：代表一个簇。高度越高，簇包含的点越多
        * **水平线**：表示簇的合并。水平线的高度表示合并时的距离（不相似度）
        * **纵轴**：表示簇合并时的距离或不相似度
        * **横轴**：表示数据点或样本索引
        * **高度差**：反映簇之间的分离程度。高度差大表示簇之间分离明显
        
        **利用树状图选择簇的数量**：
        
        1. **寻找明显的"跳跃"**：查找树状图中垂直高度的明显跳跃（较长的垂直线）。这表示在此高度合并的簇之间差异较大
        
        2. **距离阈值切割法**：
           * 在某个距离阈值水平绘制水平切割线
           * 切割线穿过的垂直线数量即为簇的数量
           * 选择切割线位置时，应寻找较长垂直线之前的位置
        
        3. **簇数量切割法**：
           * 直接指定期望的簇数量k
           * 从上到下找到形成k个簇的距离阈值
        
        4. **评估指标辅助**：
           * 对不同的簇数量计算评估指标（如轮廓系数）
           * 选择评估指标最优的簇数量
        
        最佳实践是结合业务背景、树状图结构特点和评估指标来综合判断合适的簇数量。
        """
    },
    {
        "question": "5. 假设你要对一批客户根据他们的消费金额和购买频率进行聚类，你会优先考虑K-Means还是层次聚类？为什么？如果数据量非常大（百万级别），你的选择会改变吗？",
        "answer": """
        **初始选择考虑**：
        
        对于消费金额和购买频率这类二维数据，我会先尝试**K-Means算法**，原因是：
        
        1. **简单高效**：K-Means计算效率高，实现简单
        2. **适合特征**：消费行为数据通常可以形成相对球状的簇，如"高价值客户"、"中等价值客户"、"低价值客户"等
        3. **易于解释**：K-Means生成的簇中心直观表示每个客户群的平均消费金额和频率
        4. **适合探索性分析**：可以快速尝试不同的K值来探索数据结构
        
        **也可能考虑层次聚类的情况**：
        
        1. 如果需要理解客户的层次关系（例如高价值客户中的细分群体）
        2. 如果不确定合适的簇数量，可以先用层次聚类的树状图来确定
        3. 如果怀疑客户群体不是简单的球形分布
        
        **当数据量非常大（百万级别）时**：
        
        我的选择会明确偏向**K-Means**或其变种（如Mini-batch K-Means），原因是：
        
        1. **计算复杂度**：层次聚类的复杂度为O(n^3)或O(n^2log n)，对于百万级数据不切实际
        2. **内存需求**：层次聚类需要存储距离矩阵，对大型数据集来说内存需求巨大
        3. **可扩展性**：K-Means的复杂度为O(nkt)（n为样本数，k为簇数，t为迭代次数），更适合大数据
        4. **并行计算**：K-Means容易并行化，适合分布式计算
        
        **大数据情况下的替代方案**：
        
        1. 使用**BIRCH**（Balanced Iterative Reducing and Clustering using Hierarchies）算法，它结合了层次思想但适用于大数据集
        2. 对数据进行**采样**，在样本上使用层次聚类确定K值，然后在完整数据上使用K-Means
        3. 使用**近似层次聚类**算法，如CURE或ROCK
        """
    }
]

# 使用expander显示问题和答案
for i, q in enumerate(questions):
    with st.expander(q["question"]):
        if st.button(f"查看参考答案 {i+1}", key=f"answer_{i}"):
            st.markdown(q["answer"])
            
        else:
            st.info("点击上方按钮查看参考答案。在实际学习中，建议先自己思考作答，然后再查看参考答案。")

# 添加额外练习题
st.header("额外练习")

st.markdown("""
### 编程练习

1. 尝试使用不同的连接标准（ward, average, complete, single）对同一数据集进行层次聚类，并比较树状图和聚类结果的差异。

2. 尝试将K-Means和层次聚类应用于一个包含非球状簇的数据集（如半月形或环形数据），比较两种算法的表现。

3. 实现一个简单的可视化工具，允许用户调整树状图的切割高度，并实时显示对应的聚类结果。

### 思考题

1. 在什么情况下，即使面对大规模数据集，我们也可能优先考虑层次聚类而非K-Means？

2. 层次聚类的结果是确定性的，但K-Means的结果可能因初始质心的不同而变化。这一特性对算法选择有何影响？

3. 如何将层次聚类和K-Means结合使用，发挥各自的优势？
""")

# 添加页脚
st.markdown("---")
st.markdown("© 2024 机器学习课程 | 交互式聚类算法课件") 